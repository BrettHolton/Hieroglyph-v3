
Items to do:

- Consider adding a shader loading function that will try to create each of the shaders by XXMain functions for the shader model specified by the renderer.  This should simplify the loading code for the application significantly, and still allow for lower level functions to manually load each shader if needed.

- Add the shader programs to the ShaderStageDX11 classes as part of their cached state. 

[DONE] - Add smarter ways to set each of the resource arrays, taking into consideration the changes between settings.

[DONE] - Create a class to represent the programmable shader stages.  This will allow a reusable functionality for managing the resources that have been/are bound to a stage, including caching the resources, clearing them all out, and perhaps performing validation on the type of resource being bound.

- Consider housing the UAV/SRV/RTV/DSV in the resource classes.  This would reduce the number of items that the end user needs to keep track of.  Perhaps an index structure would be more appropriate for the application to reference?

- Add shader input/output match validation to the RenderEffectDX11 class.  This will provide some warning to the user if they have mistakenly used the incorrect shaders.

- Consider changing the entity world/local matrices to reside in the EntityRenderParams object.  This could also contain the Translate and Rotation variables, which would provide a true 'renderable' data structure while removing responsibilities from the entity.

- Create the configuration classes for ResourceView subclasses.

- Revamp the configuration classes to allow easier setting of common properties!

[DONE] - Update PerlinNoise class to standard naming convention.

- Modify shader loading function to use contextual information to choose the main function name and/or the model to compile with.

[DONE] - Add standard handler for renderer that doesn't support a particular feature level as requested in the initialize method.

[DONE] - Automatically create constant buffers if they don't exist when an effect is being used in rendering.  This will allow the user to create and use specialized buffers if needed, but not require manual creation if a standard one will be used.